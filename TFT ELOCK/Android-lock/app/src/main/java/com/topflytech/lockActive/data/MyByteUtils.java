package com.topflytech.lockActive.data;import java.io.DataInput;import java.nio.ByteBuffer;import java.text.ParseException;import java.util.ArrayList;import java.util.Arrays;import java.util.Date;import java.util.List;/** * @author zhenhui.chen * @version 1.0.0 * @since 2013-03-24 */public class MyByteUtils {    public static boolean isShowVirtualData = false;    public static ArrayList<Integer> columnWidth = new ArrayList<Integer>(){{        add(400);        add(400);        add(500);        add(800);        add(300);        add(300);        add(200);        add(200);        add(200);        add(800);    }};    public static String binaryFormat(String binaryStr,int len){        int binaryLen = binaryStr.length();        if(binaryLen >= len){            return binaryStr.substring(binaryLen - len ,binaryLen);        }else{            int fixZeroLen = len - binaryLen;            String fixZero = "";            for(int i = 0;i < fixZeroLen;i++){                fixZero += "0";            }            return fixZero + binaryStr;        }    }    public static String parseSoftwareVersion(byte[] bytes,int index){        if(bytes.length < index + 3){            return "";        }        int all = bytes2Short(bytes,index);        int version1 = bytes[index] >> 5;        int version2 = (all & 0x1FFF) >> 7;        int version3 = all & 0x7f;        byte testByte = bytes[index + 2];        if(testByte != 0 && bytes.length != 7){            String testDesc = new String(new byte[]{testByte});            return String.format("%d.%d.%02d %s",version1,version2,version3,testDesc);        }else{            return String.format("%d.%d.%02d",version1,version2,version3);        }    }    public static String parseHardwareVersion(byte hardwareByte){        int hardwareInt = Integer.valueOf(Integer.toHexString(hardwareByte & 0xFF));        if(hardwareInt < 10.0f){            return String.valueOf((hardwareInt - 1 + 10) / 10.0f);        }        return String.valueOf(hardwareInt / 10.0f);    }    private static String[] binaryArray =            {"0000","0001","0010","0011",                    "0100","0101","0110","0111",                    "1000","1001","1010","1011",                    "1100","1101","1110","1111"};    public static String bytes2BinaryStr(byte[] bArray){        String outStr = "";        int pos = 0;        for(byte b:bArray){            //����λ            pos = (b&0xF0)>>4;            outStr+=binaryArray[pos];            //����λ            pos=b&0x0F;            outStr+=binaryArray[pos];        }        return outStr;    }    public static byte[] binaryToByte(String binaryStr){        if(binaryStr.length() % 8 != 0){            return new byte[]{};        }        int len = binaryStr.length() / 8;        byte[] result = new byte[len];        for(int i = 0 ;i < len;i++){            String highPosStr = binaryStr.substring(i*8,i * 8 + 4);            int highPos = 0;            for(;highPos < binaryArray.length;highPos++){                if(highPosStr.equals(binaryArray[highPos])){                    break;                }            }            String lowPosStr = binaryStr.substring(i * 8 + 4, i *8 + 8);            int lowPos = 0;            for(;lowPos < binaryArray.length;lowPos++){                if(lowPosStr.equals(binaryArray[lowPos])){                    break;                }            }            int value = highPos * 16 + lowPos;            result[i] = (byte)value;        }        return result;    }    public static String bytes2HexString(final byte[] bytes, int index) {        if (bytes == null || bytes.length <= 0 || index >= bytes.length) {            return null;        }        StringBuilder builder = new StringBuilder("");        for (int i = index; i < bytes.length; ++i) {            String hex = Integer.toHexString(bytes[i] & 0xFF);            if (hex.length() < 2) {                builder.append('0');            }            builder.append(hex);        }        return builder.toString();    }    public static byte[] hexString2Bytes(String hexStr) {        String hex = hexStr.replace("0x", "");        StringBuffer buffer = new StringBuffer(hex);        if (buffer.length() % 2 != 0) {            buffer.insert(0, '0');        }        final int size = buffer.length() / 2;        byte[] bytes = new byte[size];        for (int i = 0; i < size; ++i) {            bytes[i] = (byte) Integer.parseInt(buffer.substring(i * 2, (i + 1) * 2), 16);        }        return bytes;    }    public static long littleEndianBytes2Long(byte[] bytes) {        long l = 0;        for(int i = bytes.length - 1; i >=0; i--) {            l = l << 8;            l |= bytes[i];        }        return l;    }    public static long bytes2Long(byte[] bytes) {        long l = 0;        for(int i = 0; i < bytes.length; i++) {            l = l << 8;            l |= bytes[i];        }        return l;    }    public static long binStr2Long(final byte[] binaryStr) {        try {            return Long.parseLong(new String(binaryStr), 2);        } catch (NumberFormatException e) {            e.printStackTrace();        }        return 0;    }    public static byte[] short2Bytes(int number) {        byte[] bytes = new byte[2];        for (int i = 1; i >= 0; i--) {            bytes[i] = (byte)(number % 256);            number >>= 8;        }        return bytes;    }    public static byte[] littleEnddianShort2Bytes(int number) {        byte[] bytes = new byte[2];        for (int i = 1; i >= 0; i--) {            bytes[i] = (byte)(number % 256);            number >>= 8;        }        return new byte[]{bytes[1],bytes[0]};    }    public static byte[] convertSignedIntToBigEndian(int number) {        byte[] bytes = new byte[2];        bytes[0] = (byte) ((number >> 8) & 0xFF);        bytes[1] = (byte) (number & 0xFF);        return bytes;    }    public static int convertBigEndianToSignedInt(byte[] bytes,int offset) {        if (offset + 2 > bytes.length) {            throw new IllegalArgumentException("len must be 2");        }        // 大端模式：高位字节左移8位，低位字节直接参与运算        int high = (bytes[offset] & 0xFF) << 8;  // 消除符号位影响（0xFF是255，二进制11111111）        int low = bytes[offset + 1] & 0xFF;           // 确保低位字节为无符号处理        int result = high | low;        // 处理负数情况（最高位为1时）        if ((bytes[offset] & 0x80) != 0) {            result -= 0x10000;  // 16位有符号数的补码转换        }        return result;    }    public static int bytes2Short(byte[] bytes, int offset) {        if (bytes != null && bytes.length > 0 && bytes.length > offset) {            if ((bytes.length - offset) >= 2) {                short s = (short)(bytes[offset + 1] & 0xFF);                return ((int) s) | ((bytes[offset] << 8) & 0xFF00);            }        }        throw new IllegalArgumentException("invalid bytes length!");    }    public static int littleEnddianBytes2Short(byte[] bytes, int offset) {        if (bytes != null && bytes.length > 0 && bytes.length > offset) {            if ((bytes.length - offset) >= 2) {                short s = (short)(bytes[offset] & 0xFF);                return ((int) s) | ((bytes[offset + 1] << 8) & 0xFF00);            }        }        throw new IllegalArgumentException("invalid bytes length!");    }    public static int bytes2Integer(byte[] bytes, int offset) {        return ByteBuffer.wrap(bytes, offset, 4).asIntBuffer().get();    }    public static long unsignedLittleEndian4BytesToInt(byte[] buf, int pos) {        int firstByte = 0;        int secondByte = 0;        int thirdByte = 0;        int fourthByte = 0;        int index = pos;        firstByte = (0x000000FF & ((int) buf[index+ 3]));        secondByte = (0x000000FF & ((int) buf[index + 2]));        thirdByte = (0x000000FF & ((int) buf[index + 1]));        fourthByte = (0x000000FF & ((int) buf[index ]));        index = index + 4;        return ((long) (firstByte << 24 | secondByte << 16 | thirdByte << 8 | fourthByte)) & 0xFFFFFFFFL;    }    public static long unsigned4BytesToInt(byte[] buf, int pos) {        int firstByte = 0;        int secondByte = 0;        int thirdByte = 0;        int fourthByte = 0;        int index = pos;        firstByte = (0x000000FF & ((int) buf[index]));        secondByte = (0x000000FF & ((int) buf[index + 1]));        thirdByte = (0x000000FF & ((int) buf[index + 2]));        fourthByte = (0x000000FF & ((int) buf[index + 3]));        index = index + 4;        return ((long) (firstByte << 24 | secondByte << 16 | thirdByte << 8 | fourthByte)) & 0xFFFFFFFFL;    }    public static byte[] unSignedInt2Bytes(long num) {        byte[] byteNum = new byte[4];        for (int ix = 0; ix < 4; ++ix) {            int offset = 32 - (ix + 1) * 8;            byteNum[ix] = (byte) ((num >> offset) & 0xff);        }        return byteNum;    }    public static byte[] long2Bytes(long num) {        byte[] byteNum = new byte[8];        for (int ix = 0; ix < 8; ++ix) {            int offset = 64 - (ix + 1) * 8;            byteNum[ix] = (byte) ((num >> offset) & 0xff);        }        return byteNum;    }    public static float bytes2Float(byte[] bytes, int offset) {        int value;        value = bytes[offset];        value &= 0xff;        value |= ((long) bytes[offset + 1] << 8);        value &= 0xffff;        value |= ((long) bytes[offset + 2] << 16);        value &= 0xffffff;        value |= ((long) bytes[offset + 3] << 24);        return Float.intBitsToFloat(value);    }    public static float littleEndianBytes2Float(byte[] bytes, int offset) {        int value;        value = bytes[offset+3];        value &= 0xff;        value |= ((long) bytes[offset + 2] << 8);        value &= 0xffff;        value |= ((long) bytes[offset + 1] << 16);        value &= 0xffffff;        value |= ((long) bytes[offset] << 24);        return Float.intBitsToFloat(value);    }    public static boolean getBitFromByte(byte b, int index) {        if (index<0 || index>7) {            throw new IllegalArgumentException("index "+index +" is out of bound");        }        return (b>>index & 0x01) == 0x01;    }    private static String decodeImei(byte[] bytes, int index) {        if (bytes != null && index > 0 && (bytes.length - index) >= 8) {            String str = MyByteUtils.bytes2HexString(bytes, index);            return str.substring(1, 16);        }        throw new IllegalArgumentException("invalid bytes length & index!");    }    private static LocationMessage parseLockMessage(byte[] bytes) {        LocationMessage lockMessage = new LocationMessage();        int serialNo = MyByteUtils.bytes2Short(bytes, 5);        String imei =MyByteUtils.decodeImei(bytes, 7);        Date date = TimeUtils.getGTM0Date(bytes, 15);        boolean latlngValid = (bytes[21] & 0x40) != 0x00;        boolean isGpsWorking = (bytes[21] & 0x20) == 0x00;        boolean isHistoryData = (bytes[21] & 0x80) != 0x00;        int satelliteNumber = bytes[21] & 0x1F;        double altitude = latlngValid ? MyByteUtils.bytes2Float(bytes, 22) : 0;        double longitude = latlngValid ? MyByteUtils.bytes2Float(bytes,26) : 0;        double latitude = latlngValid ? MyByteUtils.bytes2Float(bytes,30) : 0;        Float speedf = 0.0f;        if (latlngValid){            try{                if (latlngValid) {                    byte[] bytesSpeed = Arrays.copyOfRange(bytes, 34, 36);                    String strSp = MyByteUtils.bytes2HexString(bytesSpeed, 0);                    if(!strSp.toLowerCase().equals("ffff")){                        speedf = Float.parseFloat(String.format("%d.%d", Integer.parseInt(strSp.substring(0, 3)), Integer.parseInt(strSp.substring(3, strSp.length()))));                    }                }            }catch (Exception e){                e.printStackTrace();            }        }        int azimuth = latlngValid ? MyByteUtils.bytes2Short(bytes, 36) : 0;        Boolean is_4g_lbs = false;        Integer mcc_4g = null;        Integer mnc_4g = null;        Long ci_4g = null;        Integer earfcn_4g_1 = null;        Integer pcid_4g_1 = null;        Integer earfcn_4g_2 = null;        Integer pcid_4g_2 = null;        Boolean is_2g_lbs = false;        Integer mcc_2g = null;        Integer mnc_2g = null;        Integer lac_2g_1 = null;        Integer ci_2g_1 = null;        Integer lac_2g_2 = null;        Integer ci_2g_2 = null;        Integer lac_2g_3 = null;        Integer ci_2g_3 = null;        if (!latlngValid){            byte lbsByte = bytes[22];            if ((lbsByte & 0x80) == 0x80){                is_4g_lbs = true;            }else{                is_2g_lbs = true;            }        }        if (is_2g_lbs){            mcc_2g = MyByteUtils.bytes2Short(bytes,22);            mnc_2g = MyByteUtils.bytes2Short(bytes,24);            lac_2g_1 = MyByteUtils.bytes2Short(bytes,26);            ci_2g_1 = MyByteUtils.bytes2Short(bytes,28);            lac_2g_2 = MyByteUtils.bytes2Short(bytes,30);            ci_2g_2 = MyByteUtils.bytes2Short(bytes,32);            lac_2g_3 = MyByteUtils.bytes2Short(bytes,34);            ci_2g_3 = MyByteUtils.bytes2Short(bytes,36);        }        if (is_4g_lbs){            mcc_4g = MyByteUtils.bytes2Short(bytes,22) & 0x7FFF;            mnc_4g = MyByteUtils.bytes2Short(bytes,24);            ci_4g = MyByteUtils.unsigned4BytesToInt(bytes, 26);            earfcn_4g_1 = MyByteUtils.bytes2Short(bytes, 30);            pcid_4g_1 = MyByteUtils.bytes2Short(bytes, 32);            earfcn_4g_2 = MyByteUtils.bytes2Short(bytes, 34);            pcid_4g_2 = MyByteUtils.bytes2Short(bytes,36);        }        int lockType = bytes[38] & 0xff;        if(lockType < 0){            lockType += 256;        }        int idLen = (bytes[39] & 0xff) * 2;        String idStr = MyByteUtils.bytes2HexString(bytes,40);        String id = idStr;        if (idStr.length() > idLen){            id = idStr.substring(0,idLen);        }        id = id.toUpperCase();        lockMessage.setProtocolHeadType(bytes[2]);        lockMessage.setSerialNo(serialNo);        lockMessage.setImei(imei);        lockMessage.setDate(date);        lockMessage.setOrignBytes(bytes);        lockMessage.setLatlngValid(latlngValid);        lockMessage.setAltitude(altitude);        lockMessage.setLongitude(longitude);        lockMessage.setLatitude(latitude);        lockMessage.setLatlngValid(latlngValid);        lockMessage.setSpeed(speedf);        lockMessage.setAzimuth(azimuth);        lockMessage.setLockType(lockType);        lockMessage.setLockId(id);        lockMessage.setIsHistoryData(isHistoryData);        lockMessage.setSatelliteNumber(satelliteNumber);        lockMessage.setGpsWorking(isGpsWorking);        lockMessage.setIs_4g_lbs(is_4g_lbs);        lockMessage.setIs_2g_lbs(is_2g_lbs);        lockMessage.setMcc_2g(mcc_2g);        lockMessage.setMnc_2g(mnc_2g);        lockMessage.setLac_2g_1(lac_2g_1);        lockMessage.setCi_2g_1(ci_2g_1);        lockMessage.setLac_2g_2(lac_2g_2);        lockMessage.setCi_2g_2(ci_2g_2);        lockMessage.setLac_2g_3(lac_2g_3);        lockMessage.setCi_2g_3(ci_2g_3);        lockMessage.setMcc_4g(mcc_4g);        lockMessage.setMnc_4g(mnc_4g);        lockMessage.setCi_4g(ci_4g);        lockMessage.setEarfcn_4g_1(earfcn_4g_1);        lockMessage.setPcid_4g_1(pcid_4g_1);        lockMessage.setEarfcn_4g_2(earfcn_4g_2);        lockMessage.setPcid_4g_2(pcid_4g_2);        return lockMessage;    }    private static LocationMessage parseDataMessage(byte[] data) {        int serialNo = MyByteUtils.bytes2Short(data, 5);        String imei = MyByteUtils.decodeImei(data, 7);        Date date = TimeUtils.getGTM0Date(data, 17);        boolean isGpsWorking = (data[15] & 0x20) == 0x00;        boolean isHistoryData = (data[15] & 0x80) != 0x00;        boolean latlngValid = (data[15] & 0x40) == 0x40;        int satelliteNumber = data[15] & 0x1F;        double altitude = latlngValid ? MyByteUtils.bytes2Float(data, 23) : 0;        double longitude = latlngValid ? MyByteUtils.bytes2Float(data,27) : 0;        double latitude = latlngValid ? MyByteUtils.bytes2Float(data,31) : 0;        Float speedf = 0.0f;        if (latlngValid){            try{                if (latlngValid) {                    byte[] bytesSpeed = Arrays.copyOfRange(data, 35, 37);                    String strSp = MyByteUtils.bytes2HexString(bytesSpeed, 0);                    if(!strSp.toLowerCase().equals("ffff")){                        speedf = Float.parseFloat(String.format("%d.%d", Integer.parseInt(strSp.substring(0, 3)), Integer.parseInt(strSp.substring(3, strSp.length()))));                    }                }            }catch (Exception e){//                e.printStackTrace();            }        }        int azimuth = latlngValid ? MyByteUtils.bytes2Short(data, 37) : 0;        Boolean is_4g_lbs = false;        Integer mcc_4g = null;        Integer mnc_4g = null;        Long ci_4g = null;        Integer earfcn_4g_1 = null;        Integer pcid_4g_1 = null;        Integer earfcn_4g_2 = null;        Integer pcid_4g_2 = null;        Boolean is_2g_lbs = false;        Integer mcc_2g = null;        Integer mnc_2g = null;        Integer lac_2g_1 = null;        Integer ci_2g_1 = null;        Integer lac_2g_2 = null;        Integer ci_2g_2 = null;        Integer lac_2g_3 = null;        Integer ci_2g_3 = null;        if (!latlngValid){            byte lbsByte = data[23];            if ((lbsByte & 0x80) == 0x80){                is_4g_lbs = true;            }else{                is_2g_lbs = true;            }        }        if (is_2g_lbs){            mcc_2g = MyByteUtils.bytes2Short(data,23);            mnc_2g = MyByteUtils.bytes2Short(data,25);            lac_2g_1 = MyByteUtils.bytes2Short(data,27);            ci_2g_1 = MyByteUtils.bytes2Short(data,29);            lac_2g_2 = MyByteUtils.bytes2Short(data,31);            ci_2g_2 = MyByteUtils.bytes2Short(data,33);            lac_2g_3 = MyByteUtils.bytes2Short(data,35);            ci_2g_3 = MyByteUtils.bytes2Short(data,37);        }        if (is_4g_lbs){            mcc_4g = MyByteUtils.bytes2Short(data,23) & 0x7FFF;            mnc_4g = MyByteUtils.bytes2Short(data,25);            ci_4g = MyByteUtils.unsigned4BytesToInt(data, 27);            earfcn_4g_1 = MyByteUtils.bytes2Short(data, 31);            pcid_4g_1 = MyByteUtils.bytes2Short(data, 33);            earfcn_4g_2 = MyByteUtils.bytes2Short(data, 35);            pcid_4g_2 = MyByteUtils.bytes2Short(data,37);        }        int axisXDirect = (data[39] & 0x80) == 0x80 ? 1 : -1;        float axisX = ((data[39] & 0x7F & 0xff) + (((data[40] & 0xf0) >> 4) & 0xff) /10.0f) * axisXDirect;        int axisYDirect = (data[40] & 0x08) == 0x08 ? 1 : -1;        float axisY = (((((data[40] & 0x07) << 4) & 0xff) + (((data[41] & 0xf0) >> 4) & 0xff)) + (data[41] & 0x0F & 0xff)/10.0f)* axisYDirect;        int axisZDirect = (data[42] & 0x80) == 0x80 ? 1 : -1;        float axisZ = ((data[42] & 0x7F & 0xff) + (((data[43] & 0xf0) >> 4) & 0xff) /10.0f) * axisZDirect;        byte[] batteryPercentBytes = new byte[]{data[44]};        String batteryPercentStr = MyByteUtils.bytes2HexString(batteryPercentBytes, 0);        int batteryPercent = 100;        if(batteryPercentStr.toLowerCase().equals("ff")){            batteryPercent = 100;        }else{            try{                batteryPercent = Integer.parseInt(batteryPercentStr);                if (0 == batteryPercent) {                    batteryPercent = 100;                }            }catch (Exception e){//                e.printStackTrace();            }        }        float deviceTemp = -999;        if ( data[45] != 0xff){            deviceTemp = (data[45] & 0x7F) * ((data[45] & 0x80) == 0x80 ? -1 : 1);        }        byte[] lightSensorBytes = new byte[]{data[46]};        String lightSensorStr = MyByteUtils.bytes2HexString(lightSensorBytes, 0);        float lightSensor = 0;        if(lightSensorStr.toLowerCase().equals("ff")){            lightSensor = -999;        }else{            try{                lightSensor = Integer.parseInt(lightSensorStr) / 10.0f;            }catch (Exception e){//                e.printStackTrace();            }        }        byte[] batteryVoltageBytes = new byte[]{data[47]};        String batteryVoltageStr = MyByteUtils.bytes2HexString(batteryVoltageBytes, 0);        float batteryVoltage = 0;        if(batteryVoltageStr.toLowerCase().equals("ff")){            batteryVoltage = -999;        }else{            try{                batteryVoltage = Integer.parseInt(batteryVoltageStr) / 10.0f;            }catch (Exception e){//                e.printStackTrace();            }        }        byte[] solarVoltageBytes = new byte[]{data[48]};        String solarVoltageStr = MyByteUtils.bytes2HexString(solarVoltageBytes, 0);        float solarVoltage = 0;        if(solarVoltageStr.toLowerCase().equals("ff")){            solarVoltage = -999;        }else{            try{                solarVoltage = Integer.parseInt(solarVoltageStr) / 10.0f;            }catch (Exception e){//                e.printStackTrace();            }        }        long mileage = MyByteUtils.unsigned4BytesToInt(data, 49);        int status = MyByteUtils.bytes2Short(data, 53);        int network = (status & 0x7F0) >> 4;        int accOnInterval = MyByteUtils.bytes2Short(data, 55);        int accOffInterval = MyByteUtils.bytes2Integer(data, 57);        int angleCompensation = (int) (data[61] & 0xff);        if (angleCompensation < 0){            angleCompensation += 256;        }        int distanceCompensation = MyByteUtils.bytes2Short(data, 62);        int heartbeatInterval = (int) data[64];        boolean isUsbCharging = (status & 0x8000) == 0x8000;        boolean isSolarCharging = (status & 0x8) == 0x8;        boolean iopIgnition = (status & 0x4) == 0x4;        byte alarmByte = data[16];        int originalAlarmCode = (int) alarmByte;        if(originalAlarmCode < 0){            originalAlarmCode += 256;        }        byte[] command = Arrays.copyOf(data, 3);        boolean isAlarmData = command[2] == 0x04;        byte status1 = data[54];        String smartPowerOpenStatus = "close";        if((status1 & 0x01) == 0x01){            smartPowerOpenStatus = "open";        }        byte status2 = data[66];        boolean isLockSim = (status2 & 0x80) == 0x80;        boolean isLockDevice = (status2 & 0x40) == 0x40;        boolean AGPSEphemerisDataDownloadSettingStatus = (status2 & 0x20) == 0x10;        boolean gSensorSettingStatus = (status2 & 0x10) == 0x10;        boolean frontSensorSettingStatus = (status2 & 0x08) == 0x08;        boolean deviceRemoveAlarmSettingStatus = (status2 & 0x04) == 0x04;        boolean openCaseAlarmSettingStatus = (status2 & 0x02) == 0x02;        boolean deviceInternalTempReadingANdUploadingSettingStatus = (status2 & 0x01) == 0x01;        byte status3 = data[67];        String smartPowerSettingStatus = "disable";        if((status3 & 0x80) == 0x80){            smartPowerSettingStatus = "enable";        }        Integer lockType = null;        if (data.length >= 71){            lockType = (int)data[70];        }        LocationMessage locationMessage = new LocationMessage();        locationMessage.setProtocolHeadType(data[2]);        locationMessage.setOrignBytes(data);//        boolean isNeedResp = (serialNo & 0x8000) != 0x8000;        locationMessage.setSerialNo(serialNo);//        locationMessage.setIsNeedResp(isNeedResp);        locationMessage.setNetworkSignal(network);        locationMessage.setImei(imei);        locationMessage.setIsSolarCharging(isSolarCharging);        locationMessage.setIsUsbCharging(isUsbCharging);        locationMessage.setSamplingIntervalAccOn(accOnInterval);        locationMessage.setSamplingIntervalAccOff(accOffInterval);        locationMessage.setAngleCompensation(angleCompensation);        locationMessage.setDistanceCompensation(distanceCompensation);        locationMessage.setGpsWorking(isGpsWorking);        locationMessage.setIsHistoryData(isHistoryData);        locationMessage.setSatelliteNumber(satelliteNumber);        locationMessage.setHeartbeatInterval(heartbeatInterval);        locationMessage.setOriginalAlarmCode(originalAlarmCode);        locationMessage.setMileage(mileage);        locationMessage.setIopIgnition(iopIgnition);        locationMessage.setIOP(locationMessage.isIopIgnition() ? 0x4000l : 0x0000l);        locationMessage.setBatteryCharge(batteryPercent);        locationMessage.setDate(date);        locationMessage.setLatlngValid(latlngValid);        locationMessage.setAltitude(altitude);        locationMessage.setLatitude(latitude);        locationMessage.setLongitude(longitude);        locationMessage.setIsLockSim(isLockSim);        locationMessage.setIsLockDevice(isLockDevice);        locationMessage.setAGPSEphemerisDataDownloadSettingStatus(AGPSEphemerisDataDownloadSettingStatus);        locationMessage.setgSensorSettingStatus(gSensorSettingStatus);        locationMessage.setFrontSensorSettingStatus(frontSensorSettingStatus);        locationMessage.setDeviceRemoveAlarmSettingStatus(deviceRemoveAlarmSettingStatus);        locationMessage.setOpenCaseAlarmSettingStatus(openCaseAlarmSettingStatus);        locationMessage.setDeviceInternalTempReadingANdUploadingSettingStatus(deviceInternalTempReadingANdUploadingSettingStatus);        if(locationMessage.isLatlngValid()) {            locationMessage.setSpeed(speedf);        } else {            locationMessage.setSpeed(0.0f);        }        locationMessage.setAzimuth(azimuth);        locationMessage.setAxisX(axisX);        locationMessage.setAxisY(axisY);        locationMessage.setAxisZ(axisZ);        locationMessage.setDeviceTemp(deviceTemp);        locationMessage.setLightSensor(lightSensor);        locationMessage.setBatteryVoltage(batteryVoltage);        locationMessage.setSolarVoltage(solarVoltage);        locationMessage.setSmartPowerSettingStatus(smartPowerSettingStatus);        locationMessage.setSmartPowerOpenStatus(smartPowerOpenStatus);        locationMessage.setIs_4g_lbs(is_4g_lbs);        locationMessage.setIs_2g_lbs(is_2g_lbs);        locationMessage.setMcc_2g(mcc_2g);        locationMessage.setMnc_2g(mnc_2g);        locationMessage.setLac_2g_1(lac_2g_1);        locationMessage.setCi_2g_1(ci_2g_1);        locationMessage.setLac_2g_2(lac_2g_2);        locationMessage.setCi_2g_2(ci_2g_2);        locationMessage.setLac_2g_3(lac_2g_3);        locationMessage.setCi_2g_3(ci_2g_3);        locationMessage.setMcc_4g(mcc_4g);        locationMessage.setMnc_4g(mnc_4g);        locationMessage.setCi_4g(ci_4g);        locationMessage.setEarfcn_4g_1(earfcn_4g_1);        locationMessage.setPcid_4g_1(pcid_4g_1);        locationMessage.setEarfcn_4g_2(earfcn_4g_2);        locationMessage.setPcid_4g_2(pcid_4g_2);        locationMessage.setLockType(lockType);        return locationMessage;    }    public static ArrayList<LocationMessage> getLocationMessage(byte[] inBytes,TopflytechByteBuf decoderBuf){        ArrayList<LocationMessage> result = new ArrayList<LocationMessage>();        decoderBuf.putBuf(inBytes);        if(decoderBuf.getReadableBytes() < 5){            return result;        }        byte[] bytes = new byte[3];        while (decoderBuf.getReadableBytes() > 5){            decoderBuf.markReaderIndex();            bytes[0] = decoderBuf.getByte(0);            bytes[1] = decoderBuf.getByte(1);            bytes[2] = decoderBuf.getByte(2);            if ((bytes[0] == 0x27 && bytes[1] == 0x27 &&                    (bytes[2] == 0x02 || bytes[2] == 0x04))){                decoderBuf.skipBytes(3);                byte[] lengthBytes = decoderBuf.readBytes(2);                int packageLength = bytes2Short(lengthBytes, 0);                decoderBuf.resetReaderIndex();                if(packageLength <= 0){                    return result;                }                if (packageLength > decoderBuf.getReadableBytes()){                    return result;                }                byte[] data = decoderBuf.readBytes(packageLength);                if (data != null){                    if(bytes[2] == 0x17){                        try {                            LocationMessage locationMessage = parseLockMessage(data);                            result.add(locationMessage);                        }catch (Exception e){                        }                    }else{                        try {                            LocationMessage locationMessage = parseDataMessage(data);                            result.add(locationMessage);                        }catch (Exception e){                        }                    }                }            }else{                decoderBuf.skipBytes(1);            }        }        return result;    }    public static int calCrc(byte[] calArray,int len){        int crc = 0xff;        for (int j = 0; j < len; j++) {            crc = crc ^ calArray[j];            for (int i = 0; i < 8; i++) {                if ((crc & 0x80) == 0x80) {                    crc = (crc << 1) ^ 0x31;                } else {                    crc = crc << 1;                }            }        }        return crc & 0xff;    }    public static boolean checkOriginHisDataCrc(byte[] byteDataArray){        int srcCrc = byteDataArray[0] & 0xff;        byte[] needCheckCrc = Arrays.copyOfRange(byteDataArray,1,byteDataArray.length);        int myCalCrc = calCrc(needCheckCrc,needCheckCrc.length);        if(myCalCrc != srcCrc){            return false;        }        return true;    }}