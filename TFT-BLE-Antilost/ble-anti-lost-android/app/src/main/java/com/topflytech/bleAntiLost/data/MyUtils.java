package com.topflytech.bleAntiLost.data;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.util.Arrays;import java.util.HashMap;public class MyUtils {    public static boolean isDebug = false;    public final static HashMap<String, HashMap<String,Integer>> controlFunc = new HashMap<String,HashMap<String,Integer>>(){{        put("antiLostConn",new HashMap<String, Integer>(){{            put("read",120);            put("write",120);        }});        put("configParam",new HashMap<String, Integer>(){{            put("read",122);            put("write",121);        }});        put("searchMode",new HashMap<String, Integer>(){{            put("read",124);            put("write",123);        }});        put("silentMode",new HashMap<String, Integer>(){{            put("read",126);            put("write",125);        }});        put("activelyDisconnect",new HashMap<String, Integer>(){{            put("write",127);        }});    }};    public static String bytes2HexString(final byte[] bytes, int index) {        if (bytes == null || bytes.length <= 0 || index >= bytes.length) {            return null;        }        StringBuilder builder = new StringBuilder("");        for (int i = index; i < bytes.length; ++i) {            String hex = Integer.toHexString(bytes[i] & 0xFF);            if (hex.length() < 2) {                builder.append('0');            }            builder.append(hex);        }        return builder.toString();    }    public static byte[] hexString2Bytes(String hexStr) {        String hex = hexStr.replace("0x", "");        StringBuffer buffer = new StringBuffer(hex);        if (buffer.length() % 2 != 0) {            buffer.insert(0, '0');        }        final int size = buffer.length() / 2;        byte[] bytes = new byte[size];        for (int i = 0; i < size; ++i) {            bytes[i] = (byte) Integer.parseInt(buffer.substring(i * 2, (i + 1) * 2), 16);        }        return bytes;    }    public static long littleEndianBytes2Long(byte[] bytes) {        long l = 0;        for(int i = bytes.length - 1; i >=0; i--) {            l = l << 8;            l |= bytes[i];        }        return l;    }    public static long bytes2Long(byte[] bytes) {        long l = 0;        for(int i = 0; i < bytes.length; i++) {            l = l << 8;            l |= bytes[i];        }        return l;    }    public static long binStr2Long(final byte[] binaryStr) {        try {            return Long.parseLong(new String(binaryStr), 2);        } catch (NumberFormatException e) {            e.printStackTrace();        }        return 0;    }    public static byte[] short2Bytes(int number) {        byte[] bytes = new byte[2];        for (int i = 1; i >= 0; i--) {            bytes[i] = (byte)(number % 256);            number >>= 8;        }        return bytes;    }    public static int bytes2Short(byte[] bytes, int offset) {        if (bytes != null && bytes.length > 0 && bytes.length > offset) {            if ((bytes.length - offset) >= 2) {                short s = (short)(bytes[offset + 1] & 0xFF);                return ((int) s) | ((bytes[offset] << 8) & 0xFF00);            }        }        throw new IllegalArgumentException("invalid bytes length!");    }    public static int byte2SignShort(byte[] inBytes,int offset){        if (inBytes != null && inBytes.length > 0 && inBytes.length > offset && (inBytes.length - offset) >= 2) {            byte[] bytes = Arrays.copyOfRange(inBytes,offset,offset + 2);            short s = ByteBuffer.wrap(bytes).getShort();            int i = s & 0xffff;            if ((i & 0x8000) > 0) {                i = i - 65535 + 1;            }            return  i;        }        throw new IllegalArgumentException("invalid bytes length!");    }    public static int bytes2Integer(byte[] bytes, int offset) {        return ByteBuffer.wrap(bytes, offset, 4).asIntBuffer().get();    }    public static long unsignedLittleEndian4BytesToInt(byte[] buf, int pos) {        int firstByte = 0;        int secondByte = 0;        int thirdByte = 0;        int fourthByte = 0;        int index = pos;        firstByte = (0x000000FF & ((int) buf[index+ 3]));        secondByte = (0x000000FF & ((int) buf[index + 2]));        thirdByte = (0x000000FF & ((int) buf[index + 1]));        fourthByte = (0x000000FF & ((int) buf[index ]));        index = index + 4;        return ((long) (firstByte << 24 | secondByte << 16 | thirdByte << 8 | fourthByte)) & 0xFFFFFFFFL;    }    public static long unsigned4BytesToInt(byte[] buf, int pos) {        int firstByte = 0;        int secondByte = 0;        int thirdByte = 0;        int fourthByte = 0;        int index = pos;        firstByte = (0x000000FF & ((int) buf[index]));        secondByte = (0x000000FF & ((int) buf[index + 1]));        thirdByte = (0x000000FF & ((int) buf[index + 2]));        fourthByte = (0x000000FF & ((int) buf[index + 3]));        index = index + 4;        return ((long) (firstByte << 24 | secondByte << 16 | thirdByte << 8 | fourthByte)) & 0xFFFFFFFFL;    }    public static byte[] unSignedInt2Bytes(long num) {        byte[] byteNum = new byte[4];        for (int ix = 0; ix < 4; ++ix) {            int offset = 32 - (ix + 1) * 8;            byteNum[ix] = (byte) ((num >> offset) & 0xff);        }        return byteNum;    }    public static byte[] long2Bytes(long num) {        byte[] byteNum = new byte[8];        for (int ix = 0; ix < 8; ++ix) {            int offset = 64 - (ix + 1) * 8;            byteNum[ix] = (byte) ((num >> offset) & 0xff);        }        return byteNum;    }    public static float bytes2Float(byte[] bytes, int offset) {        int value;        value = bytes[offset];        value &= 0xff;        value |= ((long) bytes[offset + 1] << 8);        value &= 0xffff;        value |= ((long) bytes[offset + 2] << 16);        value &= 0xffffff;        value |= ((long) bytes[offset + 3] << 24);        return Float.intBitsToFloat(value);    }    public static float littleEndianBytes2Float(byte[] bytes, int offset) {        int value;        value = bytes[offset+3];        value &= 0xff;        value |= ((long) bytes[offset + 2] << 8);        value &= 0xffff;        value |= ((long) bytes[offset + 1] << 16);        value &= 0xffffff;        value |= ((long) bytes[offset] << 24);        return Float.intBitsToFloat(value);    }    public static boolean getBitFromByte(byte b, int index) {        if (index<0 || index>7) {            throw new IllegalArgumentException("index "+index +" is out of bound");        }        return (b>>index & 0x01) == 0x01;    }    public static int calCrc(byte[] calArray,int len){        int crc = 0xff;        for (int j = 0; j < len; j++) {            crc = crc ^ calArray[j];            for (int i = 0; i < 8; i++) {                if ((crc & 0x80) == 0x80) {                    crc = (crc << 1) ^ 0x31;                } else {                    crc = crc << 1;                }            }        }        return crc & 0xff;    }    public static byte[] getInterActiveCmd(String pwd,Integer cmdHead,byte[] content){        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();        try {            outputStream.write(pwd.getBytes());            outputStream.write(cmdHead);            if(content != null){                outputStream.write(content, 0, content.length);            }            byte[] realContent = outputStream.toByteArray();            int crc = MyUtils.calCrc(realContent,realContent.length);            outputStream.write(crc);            return outputStream.toByteArray();        } catch (Exception e) {            e.printStackTrace();        } finally {            try {                outputStream.close();            } catch (IOException e) {                e.printStackTrace();            }        }        return new byte[]{};    }}