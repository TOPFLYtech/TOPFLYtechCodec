package com.topflytech.lockActive.data;import java.nio.ByteBuffer;/** * @author zhenhui.chen * @version 1.0.0 * @since 2013-03-24 */public class MyByteUtils {    public static String binaryFormat(String binaryStr,int len){        int binaryLen = binaryStr.length();        if(binaryLen >= len){            return binaryStr.substring(binaryLen - len ,binaryLen);        }else{            int fixZeroLen = len - binaryLen;            String fixZero = "";            for(int i = 0;i < fixZeroLen;i++){                fixZero += "0";            }            return fixZero + binaryStr;        }    }    private static String[] binaryArray =            {"0000","0001","0010","0011",                    "0100","0101","0110","0111",                    "1000","1001","1010","1011",                    "1100","1101","1110","1111"};    public static String bytes2BinaryStr(byte[] bArray){        String outStr = "";        int pos = 0;        for(byte b:bArray){            //����λ            pos = (b&0xF0)>>4;            outStr+=binaryArray[pos];            //����λ            pos=b&0x0F;            outStr+=binaryArray[pos];        }        return outStr;    }    public static byte[] binaryToByte(String binaryStr){        if(binaryStr.length() % 8 != 0){            return new byte[]{};        }        int len = binaryStr.length() / 8;        byte[] result = new byte[len];        for(int i = 0 ;i < len;i++){            String highPosStr = binaryStr.substring(i*8,i * 8 + 4);            int highPos = 0;            for(;highPos < binaryArray.length;highPos++){                if(highPosStr.equals(binaryArray[highPos])){                    break;                }            }            String lowPosStr = binaryStr.substring(i * 8 + 4, i *8 + 8);            int lowPos = 0;            for(;lowPos < binaryArray.length;lowPos++){                if(lowPosStr.equals(binaryArray[lowPos])){                    break;                }            }            int value = highPos * 16 + lowPos;            result[i] = (byte)value;        }        return result;    }    public static String bytes2HexString(final byte[] bytes, int index) {        if (bytes == null || bytes.length <= 0 || index >= bytes.length) {            return null;        }        StringBuilder builder = new StringBuilder("");        for (int i = index; i < bytes.length; ++i) {            String hex = Integer.toHexString(bytes[i] & 0xFF);            if (hex.length() < 2) {                builder.append('0');            }            builder.append(hex);        }        return builder.toString();    }    public static byte[] hexString2Bytes(String hexStr) {        String hex = hexStr.replace("0x", "");        StringBuffer buffer = new StringBuffer(hex);        if (buffer.length() % 2 != 0) {            buffer.insert(0, '0');        }        final int size = buffer.length() / 2;        byte[] bytes = new byte[size];        for (int i = 0; i < size; ++i) {            bytes[i] = (byte) Integer.parseInt(buffer.substring(i * 2, (i + 1) * 2), 16);        }        return bytes;    }    public static long littleEndianBytes2Long(byte[] bytes) {        long l = 0;        for(int i = bytes.length - 1; i >=0; i--) {            l = l << 8;            l |= bytes[i];        }        return l;    }    public static long bytes2Long(byte[] bytes) {        long l = 0;        for(int i = 0; i < bytes.length; i++) {            l = l << 8;            l |= bytes[i];        }        return l;    }    public static long binStr2Long(final byte[] binaryStr) {        try {            return Long.parseLong(new String(binaryStr), 2);        } catch (NumberFormatException e) {            e.printStackTrace();        }        return 0;    }    public static byte[] short2Bytes(int number) {        byte[] bytes = new byte[2];        for (int i = 1; i >= 0; i--) {            bytes[i] = (byte)(number % 256);            number >>= 8;        }        return bytes;    }    public static int bytes2Short(byte[] bytes, int offset) {        if (bytes != null && bytes.length > 0 && bytes.length > offset) {            if ((bytes.length - offset) >= 2) {                short s = (short)(bytes[offset + 1] & 0xFF);                return ((int) s) | ((bytes[offset] << 8) & 0xFF00);            }        }        throw new IllegalArgumentException("invalid bytes length!");    }    public static int littleEnddianBytes2Short(byte[] bytes, int offset) {        if (bytes != null && bytes.length > 0 && bytes.length > offset) {            if ((bytes.length - offset) >= 2) {                short s = (short)(bytes[offset] & 0xFF);                return ((int) s) | ((bytes[offset + 1] << 8) & 0xFF00);            }        }        throw new IllegalArgumentException("invalid bytes length!");    }    public static int bytes2Integer(byte[] bytes, int offset) {        return ByteBuffer.wrap(bytes, offset, 4).asIntBuffer().get();    }    public static long unsignedLittleEndian4BytesToInt(byte[] buf, int pos) {        int firstByte = 0;        int secondByte = 0;        int thirdByte = 0;        int fourthByte = 0;        int index = pos;        firstByte = (0x000000FF & ((int) buf[index+ 3]));        secondByte = (0x000000FF & ((int) buf[index + 2]));        thirdByte = (0x000000FF & ((int) buf[index + 1]));        fourthByte = (0x000000FF & ((int) buf[index ]));        index = index + 4;        return ((long) (firstByte << 24 | secondByte << 16 | thirdByte << 8 | fourthByte)) & 0xFFFFFFFFL;    }    public static long unsigned4BytesToInt(byte[] buf, int pos) {        int firstByte = 0;        int secondByte = 0;        int thirdByte = 0;        int fourthByte = 0;        int index = pos;        firstByte = (0x000000FF & ((int) buf[index]));        secondByte = (0x000000FF & ((int) buf[index + 1]));        thirdByte = (0x000000FF & ((int) buf[index + 2]));        fourthByte = (0x000000FF & ((int) buf[index + 3]));        index = index + 4;        return ((long) (firstByte << 24 | secondByte << 16 | thirdByte << 8 | fourthByte)) & 0xFFFFFFFFL;    }    public static byte[] unSignedInt2Bytes(long num) {        byte[] byteNum = new byte[4];        for (int ix = 0; ix < 4; ++ix) {            int offset = 32 - (ix + 1) * 8;            byteNum[ix] = (byte) ((num >> offset) & 0xff);        }        return byteNum;    }    public static byte[] long2Bytes(long num) {        byte[] byteNum = new byte[8];        for (int ix = 0; ix < 8; ++ix) {            int offset = 64 - (ix + 1) * 8;            byteNum[ix] = (byte) ((num >> offset) & 0xff);        }        return byteNum;    }    public static float bytes2Float(byte[] bytes, int offset) {        int value;        value = bytes[offset];        value &= 0xff;        value |= ((long) bytes[offset + 1] << 8);        value &= 0xffff;        value |= ((long) bytes[offset + 2] << 16);        value &= 0xffffff;        value |= ((long) bytes[offset + 3] << 24);        return Float.intBitsToFloat(value);    }    public static float littleEndianBytes2Float(byte[] bytes, int offset) {        int value;        value = bytes[offset+3];        value &= 0xff;        value |= ((long) bytes[offset + 2] << 8);        value &= 0xffff;        value |= ((long) bytes[offset + 1] << 16);        value &= 0xffffff;        value |= ((long) bytes[offset] << 24);        return Float.intBitsToFloat(value);    }    public static boolean getBitFromByte(byte b, int index) {        if (index<0 || index>7) {            throw new IllegalArgumentException("index "+index +" is out of bound");        }        return (b>>index & 0x01) == 0x01;    }}